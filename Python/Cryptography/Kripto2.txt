Lietuvių kalbos abėcėlė
____________________________________________

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 
A Ą B C Č D E Ę Ė F G  H  I  Į  Y  J  K

17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
L  M  N  O  P  R  S  Š  T  U  Ų  Ū  V  Z  ž
___________________________________________

6  -> 0
14 -> 24
1)
abc=u'AĄBCČDEĘĖFGHIĮYJKLMNOPRSŠTUŲŪVZŽ'
n=len(abc)
def Ceasar(tekst,k1,k2):
    tekstU=tekst.upper()
    t=u''
    for r in tekstU:
        if r in abc:
            t+=r
    c=u''
    for r in t:
        m=(k1abc.index(r)+k2)%n
        c+=abc[m]
    return c
sifr = u'EYFČB FERČR EŪEŠE GREŪE ŠEGEČ' #EY -> AŠ 
#[abc.index(u'E'),abc.index(u'Y'),abc.index(u'A'),abc.index(u'Š')]

#[6, 14, 0, 24] #[6 -> 0 , 14 -> 24]
#0=6*L1+L2, #24 = 14*L1+L2
L1 = 3 % 32
L2 = -18 % 32

Ceasar(sifr,L1,L2)

2)
abc=u'AĄBCČDEĘĖFGHIĮYJKLMNOPRSŠTUŲŪVZŽ'
n=len(abc)
def Ceasar(tekst,k1,k2):
    tekstU=tekst.upper()
    t=u''
    for r in tekstU:
        if r in abc:
            t+=r
    c=u''
    for r in t:
        m=(k1*abc.index(r)+k2)%n
        c+=abc[m]
    return c
sifr = u'ŲLSHL ŲNĘŽH LGCŲC ČLZDŽ RPSRŪ' #Ų -> K 27 -> 16
#[abc.index(u'Ų'),abc.index(u'K')]
#[27, 16]
#16=27*l1+l2, l2 = 16-27* l1 , l1=1,3,5,....,31 l1=2i+1, i =0,...,15

#[12, 17]
#17=12l1+l2, l2 = 17-12* l1 , l1=1,3,5,....,31 l1=2i+1, i =0,...,15

for i in range(0,16):
    l1=2*i+1
    l2 = 16-27* l1
    print(Ceasar(sifr,l1,l2),l1,l2)
3) 
abc=u'AĄBCČDEĘĖFGHIĮYJKLMNOPRSŠTUŲŪVZŽ'
n=len(abc)
def Ceasar(tekst,k1,k2):
    tekstU=tekst.upper()
    t=u''
    for r in tekstU:
        if r in abc:
            t+=r
    c=u''
    for r in t:
        m=(k1*abc.index(r)+k2)%n
        c+=abc[m]
    return c
# Check if two numbers are coprime (needed for k1)
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Valid multiplicative keys (k1 values must be coprime with n)
valid_k1_values = [k1 for k1 in range(1, n) if gcd(k1, n) == 1]

# Encrypted text
sifr = u'ĘVUZĖ UFŪZĄ IRĄZĘ KUZĘZ UZLŪI'
'''
# Try all combinations of k1 and k2
for k1 in valid_k1_values:  # k1 must be coprime with n
    for k2 in range(n):     # k2 can be any value between 0 and n-1
        decrypted_text = Ceasar(sifr, k1, k2)
        print(f"Decrypted with k1={k1}, k2={k2}: {decrypted_text}")
'''
k1=19
k2=18
decrypted_text = Ceasar(sifr, k1, k2)
print(f"Decrypted with k1={k1}, k2={k2}: {decrypted_text}")

4) 
abc=u'AĄBCČDEĘĖFGHIĮYJKLMNOPRSŠTUŲŪVZŽ'
n=len(abc)
def Ceasar(tekst,k1, k2):
    tekstU=tekst.upper()
    t=u''
    for r in tekstU:
        if r in abc:
            t+=r
    c=u''
    for r in t:
        m=(k1*abc.index(r)+k2)%n
        c+=abc[m]
    return c

#raktas=[18, 9, 29, 27]
Ka1 =3/25
Ka2 =-1/25
Ka3 =-29/225
Ka4 =2/25
Ka = [Ka1, Ka2, Ka3, Ka4] # < Tavo rakto atvirkštinė matrica

message = u'UVČBGTZJYOROŽĮŠINTYAMRŠČLĘĄSTCĄPUNTĘNTĘGJSĘDŠĖĘĖŠIČUDŲZJYĄĖYBĄŪMYVOG'
z = 0
ans = u''
while(z < 56):
    l1 = message[z]
    l2 = message[z+1]
    [c1,c2]= [abc.index(l1),abc.index(l2)] # < Tavo teksto raidės iš eilės, po dvi
    [m1,m2] = [(Ka1*c1 + Ka3* c2)%n, (Ka2*c1 + Ka4 * c2)%n]
    ans = ans + abc[m1]
    ans = ans + abc[m2]
    z+=1
    z+=1
print(ans)